<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Offline Diagnostics - LuxuryHotelPro</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #1a1a2e;
      color: #e0e0e0;
      padding: 20px;
      min-height: 100vh;
    }
    
    h1 {
      color: #4fd1c5;
      font-size: 20px;
      margin-bottom: 20px;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    
    .badge {
      font-size: 12px;
      padding: 4px 8px;
      border-radius: 4px;
      font-weight: 500;
    }
    
    .badge-online {
      background: #22c55e;
      color: white;
    }
    
    .badge-offline {
      background: #ef4444;
      color: white;
    }
    
    .badge-syncing {
      background: #3b82f6;
      color: white;
      animation: pulse 1s infinite;
    }
    
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.6; }
    }
    
    .section {
      background: #252541;
      border-radius: 8px;
      padding: 16px;
      margin-bottom: 16px;
    }
    
    .section-title {
      color: #94a3b8;
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 12px;
    }
    
    .stats-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 12px;
    }
    
    .stat-item {
      background: #1a1a2e;
      padding: 12px;
      border-radius: 6px;
    }
    
    .stat-label {
      font-size: 11px;
      color: #64748b;
      margin-bottom: 4px;
    }
    
    .stat-value {
      font-size: 18px;
      font-weight: 600;
      color: #f1f5f9;
    }
    
    .stat-value.online {
      color: #22c55e;
    }
    
    .stat-value.offline {
      color: #ef4444;
    }
    
    .stat-value.syncing {
      color: #3b82f6;
    }
    
    .logs-container {
      max-height: 300px;
      overflow-y: auto;
      background: #0f0f1a;
      border-radius: 6px;
      padding: 8px;
      font-family: 'Monaco', 'Menlo', monospace;
      font-size: 11px;
    }
    
    .log-entry {
      padding: 4px 8px;
      border-bottom: 1px solid #252541;
      display: flex;
      gap: 8px;
    }
    
    .log-entry:last-child {
      border-bottom: none;
    }
    
    .log-time {
      color: #64748b;
      flex-shrink: 0;
    }
    
    .log-level {
      flex-shrink: 0;
      width: 50px;
      font-weight: 600;
    }
    
    .log-level.info {
      color: #3b82f6;
    }
    
    .log-level.warn {
      color: #f59e0b;
    }
    
    .log-level.error {
      color: #ef4444;
    }
    
    .log-level.debug {
      color: #8b5cf6;
    }
    
    .log-message {
      color: #e0e0e0;
      word-break: break-word;
    }
    
    .spinner {
      width: 16px;
      height: 16px;
      border: 2px solid #4fd1c5;
      border-top-color: transparent;
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
      display: inline-block;
      margin-left: 8px;
    }
    
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    
    .empty-state {
      color: #64748b;
      text-align: center;
      padding: 20px;
      font-style: italic;
    }
    
    .refresh-btn {
      background: #4fd1c5;
      color: #1a1a2e;
      border: none;
      padding: 8px 16px;
      border-radius: 6px;
      cursor: pointer;
      font-weight: 500;
      font-size: 12px;
    }
    
    .refresh-btn:hover {
      background: #38b2ac;
    }
    
    .header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
    }
  </style>
</head>
<body>
  <div class="header">
    <h1>
      Offline Diagnostics
      <span id="networkBadge" class="badge badge-offline">Checking...</span>
    </h1>
    <button class="refresh-btn" onclick="refreshState()">Refresh</button>
  </div>

  <div class="section">
    <div class="section-title">Network Status</div>
    <div class="stats-grid">
      <div class="stat-item">
        <div class="stat-label">Connection</div>
        <div id="networkStatus" class="stat-value offline">Checking...</div>
      </div>
      <div class="stat-item">
        <div class="stat-label">Last Change</div>
        <div id="lastNetworkChange" class="stat-value">—</div>
      </div>
    </div>
  </div>

  <div class="section">
    <div class="section-title">
      Sync Status
      <span id="syncSpinner" class="spinner" style="display: none;"></span>
    </div>
    <div class="stats-grid">
      <div class="stat-item">
        <div class="stat-label">Status</div>
        <div id="syncStatus" class="stat-value">Idle</div>
      </div>
      <div class="stat-item">
        <div class="stat-label">Pending Queue</div>
        <div id="pendingQueue" class="stat-value">0</div>
      </div>
      <div class="stat-item">
        <div class="stat-label">Last Sync</div>
        <div id="lastSync" class="stat-value">—</div>
      </div>
      <div class="stat-item">
        <div class="stat-label">Synced / Failed</div>
        <div id="syncedFailed" class="stat-value">0 / 0</div>
      </div>
    </div>
  </div>

  <div class="section">
    <div class="section-title">Live Logs (Last 100)</div>
    <div id="logsContainer" class="logs-container">
      <div class="empty-state">No logs yet...</div>
    </div>
  </div>

  <script>
    // State
    let logs = [];
    const MAX_LOGS = 100;

    // Format timestamp
    function formatTime(timestamp) {
      if (!timestamp) return '—';
      const date = new Date(timestamp);
      return date.toLocaleTimeString('en-US', { hour12: false });
    }

    function formatDateTime(timestamp) {
      if (!timestamp) return '—';
      const date = new Date(timestamp);
      return date.toLocaleString('en-US', { 
        month: 'short', 
        day: 'numeric',
        hour: '2-digit', 
        minute: '2-digit',
        second: '2-digit',
        hour12: false 
      });
    }

    // Update network status display
    function updateNetworkDisplay(isOnline, lastChangeAt) {
      const badge = document.getElementById('networkBadge');
      const status = document.getElementById('networkStatus');
      const lastChange = document.getElementById('lastNetworkChange');

      if (isOnline) {
        badge.textContent = 'Online';
        badge.className = 'badge badge-online';
        status.textContent = 'Online';
        status.className = 'stat-value online';
      } else {
        badge.textContent = 'Offline';
        badge.className = 'badge badge-offline';
        status.textContent = 'Offline';
        status.className = 'stat-value offline';
      }

      lastChange.textContent = formatDateTime(lastChangeAt);
    }

    // Update sync status display
    function updateSyncDisplay(syncInfo) {
      const status = document.getElementById('syncStatus');
      const spinner = document.getElementById('syncSpinner');
      const pending = document.getElementById('pendingQueue');
      const lastSync = document.getElementById('lastSync');
      const syncedFailed = document.getElementById('syncedFailed');

      status.textContent = syncInfo.status.charAt(0).toUpperCase() + syncInfo.status.slice(1);
      
      if (syncInfo.status === 'syncing') {
        status.className = 'stat-value syncing';
        spinner.style.display = 'inline-block';
      } else if (syncInfo.status === 'error') {
        status.className = 'stat-value offline';
        spinner.style.display = 'none';
      } else {
        status.className = 'stat-value';
        spinner.style.display = 'none';
      }

      pending.textContent = syncInfo.queued.toString();
      lastSync.textContent = formatDateTime(syncInfo.lastSyncAt);
      syncedFailed.textContent = `${syncInfo.synced} / ${syncInfo.failed}`;
    }

    // Render logs
    function renderLogs() {
      const container = document.getElementById('logsContainer');
      
      if (logs.length === 0) {
        container.innerHTML = '<div class="empty-state">No logs yet...</div>';
        return;
      }

      container.innerHTML = logs.map(log => `
        <div class="log-entry">
          <span class="log-time">${formatTime(log.timestamp)}</span>
          <span class="log-level ${log.level}">${log.level.toUpperCase()}</span>
          <span class="log-message">${log.message}</span>
        </div>
      `).join('');

      // Auto-scroll to bottom
      container.scrollTop = container.scrollHeight;
    }

    // Add a log entry
    function addLog(logEvent) {
      logs.push(logEvent);
      if (logs.length > MAX_LOGS) {
        logs = logs.slice(-MAX_LOGS);
      }
      renderLogs();
    }

    // Refresh state from main process
    async function refreshState() {
      try {
        // Use IPC to get diagnostics state
        if (window.electronAPI && window.electronAPI.getDiagnosticsState) {
          const state = await window.electronAPI.getDiagnosticsState();
          updateNetworkDisplay(state.network.isOnline, state.network.lastChangeAt);
          updateSyncDisplay(state.sync);
          logs = state.logs || [];
          renderLogs();
        }
      } catch (error) {
        console.error('Failed to refresh state:', error);
      }
    }

    // Listen for updates from main process
    function setupListeners() {
      // Network status updates
      if (window.electronAPI && window.electronAPI.onOnlineStatusChange) {
        window.electronAPI.onOnlineStatusChange((isOnline) => {
          updateNetworkDisplay(isOnline, Date.now());
        });
      }

      // Sync updates
      if (window.electronAPI && window.electronAPI.onSyncEvent) {
        window.electronAPI.onSyncEvent((syncInfo) => {
          updateSyncDisplay(syncInfo);
        });
      }

      // Listen for log updates via custom event from preload
      window.addEventListener('log:update', (event) => {
        addLog(event.detail);
      });
    }

    // Initialize
    document.addEventListener('DOMContentLoaded', () => {
      setupListeners();
      refreshState();
      
      // Refresh every 5 seconds
      setInterval(refreshState, 5000);
    });
  </script>
</body>
</html>
